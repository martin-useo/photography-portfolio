<!DOCTYPE html>
<html lang="en" class="scroll-smooth">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Martin USEO - Portfolio</title>
  <meta name="description"
    content="Hello there, I'm Martin USEO – a freelance photographer based in Paris, France. Welcome to my portfolio." />
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="dist/assets/favicon.ico" />
  <link rel="stylesheet" href="dist/output.css" />
  <!-- Alpine.js -->
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <!-- Start - Fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Signika:wght@400;700&display=swap" rel="stylesheet">
  <!-- End - Fonts -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      content: ["./dist/*.{html,js}"],
      theme: {
        extend:
                {
                  fontFamily: {
                    'nothingyoucoulddo': ['Nothing You Could Do', 'cursive'],
                    'signika': ['Signika', 'sans-serif'],
                  },
                },
      },
      plugins: [],
    }
  </script>
</head>

<body
  class="dark:bg-black bg-white h-screen text-black dark:text-white opacity-0 animate-fade-in transition duration-500 overflow-hidden">
  <!-- Background Canvas with Images -->
  <div class="fixed inset-0 w-full h-full z-0" id="background-canvas">
    <div class="flex flex-wrap w-full h-full items-stretch transition-opacity duration-500" id="portfolio-grid">
    </div>
    <!-- Overlay for better button visibility -->
    <div class="absolute inset-0 bg-black/30 dark:bg-black/50"></div>
  </div>

  <!-- Main Content - Title and Button -->
  <div class="relative z-10 h-screen flex flex-col items-center justify-center overflow-hidden px-4">
    <h1 class="text-6xl md:text-8xl font-signika font-bold text-white mb-12 text-center drop-shadow-2xl">
      MARTIN USEO
    </h1>
    <a href="dist/portfolio/nature.html" 
       class="px-8 md:px-12 py-4 md:py-6 bg-white/70 dark:bg-white/10 backdrop-blur-sm text-black dark:text-white text-xl md:text-2xl font-signika font-bold rounded-lg shadow-lg hover:bg-white/80 dark:hover:bg-white/20 transition-all duration-300 transform hover:scale-105 active:scale-100 md:hover:scale-105 border-2 border-black/20 dark:border-white/20">
      DÉCOUVRIR LE PORTFOLIO
    </a>
  </div>

  <script src="dist/images-config.js"></script>
  <script>
    // Layouts prédéfinis pour la disposition des images
    const LAYOUTS = [
      {
        name: 'portrait-left-landscape-right',
        description: 'Portrait à gauche, deux paysages à droite',
        structure: [
          { width: 'md:w-1/3', height: 'h-full', isLeftColumn: true }, // Portrait à gauche
          { width: 'md:w-2/3', height: 'h-1/2', isRightColumn: true, isTop: true },  // Paysage 1 en haut à droite
          { width: 'md:w-2/3', height: 'h-1/2', isRightColumn: true, isBottom: true }   // Paysage 2 en bas à droite
        ],
        useColumns: true
      },
      {
        name: 'landscape-top-portrait-bottom',
        description: 'Deux paysages en haut, portrait en bas',
        structure: [
          { width: 'md:w-1/2', height: 'h-1/2' },  // Paysage 1 en haut gauche
          { width: 'md:w-1/2', height: 'h-1/2' },  // Paysage 2 en haut droite
          { width: 'w-full', height: 'h-1/2' }     // Portrait en bas pleine largeur
        ]
      },
      {
        name: 'three-column-grid',
        description: 'Trois images en colonnes égales',
        structure: [
          { width: 'md:w-1/3', height: 'h-full' },
          { width: 'md:w-1/3', height: 'h-full' },
          { width: 'md:w-1/3', height: 'h-full' }
        ]
      },
      {
        name: 'full-top-two-bottom',
        description: 'Image pleine largeur en haut, deux images en bas',
        structure: [
          { width: 'w-full', height: 'h-2/3' },    // Image pleine largeur en haut
          { width: 'md:w-1/2', height: 'h-1/3' },  // Image 1 en bas gauche
          { width: 'md:w-1/2', height: 'h-1/3' }   // Image 2 en bas droite
        ]
      },
      {
        name: 'two-left-one-right',
        description: 'Deux images à gauche, une grande à droite',
        structure: [
          { width: 'md:w-1/2', height: 'h-1/2', isLeftColumn: true },  // Image 1 en haut gauche
          { width: 'md:w-1/2', height: 'h-1/2', isLeftColumn: true },  // Image 2 en bas gauche
          { width: 'md:w-1/2', height: 'h-full', isRightColumn: true }  // Image 3 pleine hauteur à droite
        ],
        useColumns: true
      }
    ];

    // Fonction pour précharger une image
    function preloadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
        img.src = src;
      });
    }

    // Fonction pour précharger toutes les images
    async function preloadAllImages(images) {
      const preloadPromises = images.map(img => 
        preloadImage(img.src).catch(err => {
          console.warn(`Image failed to load: ${img.src}`, err);
          return null; // Retourner null pour les images qui échouent
        })
      );
      return Promise.all(preloadPromises);
    }

    // Fonction pour sélectionner un layout aléatoire
    function getRandomLayout() {
      return LAYOUTS[Math.floor(Math.random() * LAYOUTS.length)];
    }

    // Fonction pour organiser les images selon un layout
    function organizeImagesForLayout(images, layout) {
      const shuffledImages = [...images].sort(() => Math.random() - 0.5);
      
      // Séparer les images par format (portrait/landscape) plutôt que par catégorie
      const portraitImages = shuffledImages.filter(img => img.format === 'portrait');
      const landscapeImages = shuffledImages.filter(img => img.format === 'landscape');
      
      // Si format n'est pas défini, utiliser la catégorie comme fallback
      const portraits = portraitImages.length > 0 ? portraitImages : shuffledImages.filter(img => img.category === 'portraits');
      const landscapes = landscapeImages.length > 0 ? landscapeImages : shuffledImages.filter(img => img.category === 'nature');
      
      const organized = [];
      const usedImages = new Set(); // Pour éviter les doublons
      let portraitIndex = 0;
      let landscapeIndex = 0;
      let allImagesIndex = 0;
      
      console.log(`Organizing images for layout: ${layout.name}`);
      console.log(`- Portrait images available: ${portraits.length}`);
      console.log(`- Landscape images available: ${landscapes.length}`);
      console.log(`- Total images: ${shuffledImages.length}`);
      console.log(`- Layout structure has ${layout.structure.length} cells`);
      
      layout.structure.forEach((cell, index) => {
        let selectedImage;
        
        // Pour le layout "portrait-left-landscape-right", on force le portrait à gauche
        if (layout.name === 'portrait-left-landscape-right') {
          if (index === 0) {
            // Première position : portrait à gauche (format portrait)
            if (portraits.length > 0) {
              selectedImage = portraits[portraitIndex % portraits.length];
              portraitIndex++;
            } else {
              // Fallback si pas de portraits disponibles
              selectedImage = shuffledImages[allImagesIndex % shuffledImages.length];
              allImagesIndex++;
            }
          } else {
            // Positions suivantes : paysages à droite (format landscape)
            if (landscapes.length > 0) {
              selectedImage = landscapes[landscapeIndex % landscapes.length];
              landscapeIndex++;
            } else {
              // Fallback si pas de paysages disponibles
              selectedImage = shuffledImages[allImagesIndex % shuffledImages.length];
              allImagesIndex++;
            }
          }
        } 
        // Pour le layout "landscape-top-portrait-bottom", paysages en haut, portrait en bas
        else if (layout.name === 'landscape-top-portrait-bottom') {
          if (index < 2) {
            // Deux premières positions : paysages en haut (format landscape)
            if (landscapes.length > 0) {
              selectedImage = landscapes[landscapeIndex % landscapes.length];
              landscapeIndex++;
            } else {
              selectedImage = shuffledImages[allImagesIndex % shuffledImages.length];
              allImagesIndex++;
            }
          } else {
            // Dernière position : portrait en bas (format portrait)
            if (portraits.length > 0) {
              selectedImage = portraits[portraitIndex % portraits.length];
              portraitIndex++;
            } else {
              selectedImage = shuffledImages[allImagesIndex % shuffledImages.length];
              allImagesIndex++;
            }
          }
        }
        // Pour les autres layouts, utiliser toutes les images de manière aléatoire
        else {
          // Sélectionner une image différente pour chaque cellule
          // Garantir qu'on a toujours une image, même si on doit réutiliser
          
          // D'abord, essayer de trouver une image non utilisée
          let foundImage = false;
          for (let i = 0; i < shuffledImages.length; i++) {
            const candidate = shuffledImages[(index + i) % shuffledImages.length];
            if (!usedImages.has(candidate.src)) {
              selectedImage = candidate;
              usedImages.add(candidate.src);
              foundImage = true;
              break;
            }
          }
          
          // Si toutes les images sont déjà utilisées, réutiliser une image
          if (!foundImage) {
            selectedImage = shuffledImages[index % shuffledImages.length];
            console.warn(`  Reusing image for cell ${index + 1}: ${selectedImage.filename}`);
          }
        }
        
        if (selectedImage) {
          organized.push({
            ...selectedImage,
            layoutCell: cell
          });
          console.log(`  Cell ${index + 1}: ${selectedImage.filename} (format: ${selectedImage.format || selectedImage.category})`);
        } else {
          console.warn(`  Cell ${index + 1}: No image selected!`);
        }
      });
      
      console.log(`Organized ${organized.length} images for layout ${layout.name} (structure has ${layout.structure.length} cells)`);
      return organized;
    }

    // Variable pour stocker toutes les images (évite de les recharger à chaque fois)
    let cachedImages = null;
    let currentLayout = null;
    let currentImageIndices = []; // Indices des images actuellement affichées
    let cycleInterval = null;
    let lastChangedCell = -1; // Dernière cellule modifiée (pour éviter de modifier deux fois de suite la même)
    
    // Fonction pour créer la structure du layout avec images superposées
    function createLayoutStructure(layout, organizedImages) {
      const grid = document.getElementById('portfolio-grid');
      if (!grid) return;
      
      grid.innerHTML = '';
      
      // Appliquer le style approprié selon le layout
      if (layout.useColumns) {
        grid.className = 'flex w-full h-full';
        
        // Déterminer les largeurs des colonnes
        let leftWidth, rightWidth;
        if (layout.name === 'two-left-one-right') {
          leftWidth = 'md:w-1/2';
          rightWidth = 'md:w-1/2';
        } else {
          leftWidth = 'md:w-1/3';
          rightWidth = 'md:w-2/3';
        }
        
        const leftColumn = document.createElement('div');
        leftColumn.className = `flex flex-col ${leftWidth} w-full h-full`;
        
        const rightColumn = document.createElement('div');
        rightColumn.className = `flex flex-col ${rightWidth} w-full h-full`;
        
        organizedImages.forEach((img, index) => {
          if (!img || !img.layoutCell) return;
          
          const cellContainer = document.createElement('div');
          cellContainer.className = `w-full ${img.layoutCell.height} relative overflow-hidden`;
          cellContainer.dataset.cellIndex = index;
          
          // Créer un conteneur pour les images superposées
          const imageStack = document.createElement('div');
          imageStack.className = 'absolute inset-0';
          
          // Image initiale (visible)
          const imgElement = document.createElement('img');
          imgElement.src = img.src;
          imgElement.alt = img.alt || 'Portfolio image';
          imgElement.className = 'block h-full w-full object-cover object-center opacity-100 transition-opacity duration-1000';
          imgElement.dataset.imageIndex = index;
          imageStack.appendChild(imgElement);
          
          cellContainer.appendChild(imageStack);
          
          if (img.layoutCell.isLeftColumn) {
            leftColumn.appendChild(cellContainer);
          } else if (img.layoutCell.isRightColumn) {
            rightColumn.appendChild(cellContainer);
          }
        });
        
        grid.appendChild(leftColumn);
        grid.appendChild(rightColumn);
      } else {
        grid.className = 'flex flex-wrap w-full h-full items-stretch';
        
        const hasPartialHeights = organizedImages.some(img => 
          img.layoutCell.height && (img.layoutCell.height.includes('1/3') || img.layoutCell.height.includes('2/3'))
        );
        
        if (hasPartialHeights) {
          grid.style.display = 'flex';
          grid.style.flexWrap = 'wrap';
          grid.style.height = '100%';
        }
        
        organizedImages.forEach((img, index) => {
          if (!img || !img.layoutCell) return;
          
          const cellContainer = document.createElement('div');
          cellContainer.className = `w-full ${img.layoutCell.width} relative overflow-hidden`;
          
          if (img.layoutCell.height) {
            if (img.layoutCell.height === 'h-full') {
              cellContainer.style.height = '100%';
            } else if (img.layoutCell.height === 'h-1/2') {
              cellContainer.style.height = '50%';
            } else if (img.layoutCell.height === 'h-1/3') {
              cellContainer.style.height = '33.333333%';
            } else if (img.layoutCell.height === 'h-2/3') {
              cellContainer.style.height = '66.666667%';
            }
          }
          
          cellContainer.dataset.cellIndex = index;
          
          const imageStack = document.createElement('div');
          imageStack.className = 'absolute inset-0';
          
          const imgElement = document.createElement('img');
          imgElement.src = img.src;
          imgElement.alt = img.alt || 'Portfolio image';
          imgElement.className = 'block h-full w-full object-cover object-center opacity-100 transition-opacity duration-1000';
          imgElement.dataset.imageIndex = index;
          imageStack.appendChild(imgElement);
          
          cellContainer.appendChild(imageStack);
          grid.appendChild(cellContainer);
        });
      }
    }
    
    // Fonction pour changer une image dans une cellule spécifique
    function changeImageInCell(cellIndex, newImage) {
      const grid = document.getElementById('portfolio-grid');
      if (!grid) return;
      
      const cellContainer = grid.querySelector(`[data-cell-index="${cellIndex}"]`);
      if (!cellContainer) return;
      
      const imageStack = cellContainer.querySelector('div');
      if (!imageStack) return;
      
      // Créer la nouvelle image (invisible au début)
      const newImgElement = document.createElement('img');
      newImgElement.src = newImage.src;
      newImgElement.alt = newImage.alt || 'Portfolio image';
      newImgElement.className = 'block h-full w-full object-cover object-center opacity-0 transition-opacity duration-1000 absolute inset-0';
      newImgElement.dataset.imageIndex = cellIndex;
      
      imageStack.appendChild(newImgElement);
      
      // Fade out l'ancienne image et fade in la nouvelle
      const oldImg = imageStack.querySelector('img:not(:last-child)');
      if (oldImg) {
        oldImg.style.opacity = '0';
        setTimeout(() => {
          oldImg.remove();
        }, 1000);
      }
      
      // Fade in la nouvelle image
      setTimeout(() => {
        newImgElement.style.opacity = '1';
      }, 50);
    }
    
    // Fonction pour générer le canvas d'images en arrière-plan
    async function renderBackgroundCanvas(useTransition = false) {
      try {
        const grid = document.getElementById('portfolio-grid');
        if (!grid) {
          console.error('Portfolio grid element not found');
          return;
        }
        
        // Vérifier que IMAGES_CONFIG est disponible
        if (typeof IMAGES_CONFIG === 'undefined') {
          console.error('IMAGES_CONFIG is not defined. Make sure dist/images-config.js is loaded.');
          return;
        }
        
        // Charger toutes les images depuis la configuration centralisée (ou utiliser le cache)
        if (!cachedImages) {
          cachedImages = IMAGES_CONFIG.getAllImages('./dist/');
          
          if (!cachedImages || cachedImages.length === 0) {
            console.error('No images found in configuration');
            return;
          }
          
          console.log(`Loading ${cachedImages.length} images...`);
          
          // Précharger toutes les images (avec timeout pour éviter de bloquer)
          try {
            await Promise.race([
              preloadAllImages(cachedImages),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 5000))
            ]);
          } catch (err) {
            console.warn('Some images failed to preload, continuing anyway:', err);
          }
        }
        
        const allImages = cachedImages;
        
        // Ajouter une transition de fade-out si demandé
        if (useTransition) {
          grid.style.opacity = '0';
          grid.style.transition = 'opacity 0.5s ease-in-out';
          
          // Attendre la fin de la transition avant de changer le contenu
          await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        grid.innerHTML = ''; // Nettoyer le contenu précédent
        
        // Sélectionner un layout aléatoire
        const selectedLayout = getRandomLayout();
        console.log('Selected layout:', selectedLayout.name);
        
        // Organiser les images selon le layout
        const organizedImages = organizeImagesForLayout(allImages, selectedLayout);
        
        if (!organizedImages || organizedImages.length === 0) {
          console.error('No images organized for layout');
          return;
        }
        
        // Stocker le layout et les indices d'images actuels
        currentLayout = selectedLayout;
        currentImageIndices = organizedImages.map((img, idx) => 
          allImages.findIndex(ai => ai.src === img.src)
        );
        
        // Réinitialiser la dernière cellule modifiée
        lastChangedCell = -1;
        
        // Créer la structure du layout
        createLayoutStructure(selectedLayout, organizedImages);
        
        console.log('Background canvas rendered successfully');
      } catch (error) {
        console.error('Error rendering background canvas:', error);
        // Afficher un message d'erreur ou une image par défaut
        const grid = document.getElementById('portfolio-grid');
        if (grid) {
          grid.innerHTML = '<div class="w-full h-full bg-gray-800 flex items-center justify-center text-white">Erreur de chargement des images</div>';
        }
      }
    }
    
    // Fonction pour changer une image dans le layout actuel
    function cycleNextImage() {
      if (!currentLayout || !cachedImages || currentImageIndices.length === 0) {
        return;
      }
      
      // Trouver une cellule différente de la dernière modifiée
      let availableCells = [];
      for (let i = 0; i < currentImageIndices.length; i++) {
        if (i !== lastChangedCell) {
          availableCells.push(i);
        }
      }
      
      // Si on n'a qu'une seule cellule, on peut quand même la modifier
      if (availableCells.length === 0) {
        availableCells = [0];
      }
      
      // Sélectionner une cellule aléatoire parmi celles disponibles
      const cellIndex = availableCells[Math.floor(Math.random() * availableCells.length)];
      const currentImageIndex = currentImageIndices[cellIndex];
      
      // Trouver une nouvelle image différente qui n'est pas déjà utilisée dans le layout
      const usedImageIndices = new Set(currentImageIndices);
      let newImageIndex;
      let attempts = 0;
      const maxAttempts = 100;
      
      do {
        newImageIndex = Math.floor(Math.random() * cachedImages.length);
        attempts++;
        // Éviter la même image de la cellule ET les images déjà utilisées dans le layout
      } while ((newImageIndex === currentImageIndex || usedImageIndices.has(newImageIndex)) && attempts < maxAttempts);
      
      // Si on n'a pas trouvé d'image non utilisée (peu probable avec 7 images), 
      // prendre au moins une image différente de celle de la cellule actuelle
      if (attempts >= maxAttempts) {
        // Chercher une image qui n'est pas celle de la cellule actuelle
        do {
          newImageIndex = Math.floor(Math.random() * cachedImages.length);
        } while (newImageIndex === currentImageIndex);
        
        // Si cette image est déjà utilisée ailleurs, on la remplace quand même
        // (mieux que de bloquer le cycle)
        console.warn(`Could not find unused image, reusing image ${newImageIndex} (may create duplicate)`);
      }
      
      const newImage = cachedImages[newImageIndex];
      currentImageIndices[cellIndex] = newImageIndex;
      lastChangedCell = cellIndex;
      
      // Changer l'image dans cette cellule
      changeImageInCell(cellIndex, newImage);
      console.log(`Changed image in cell ${cellIndex + 1}/${currentImageIndices.length} to ${newImage.filename || newImage.src}`);
    }
    
    // Fonction pour démarrer le cycle infini des images
    function startProgressiveCycle() {
      if (cycleInterval) {
        clearInterval(cycleInterval);
      }
      
      // Changer une image toutes les 2 secondes, indéfiniment
      cycleInterval = setInterval(() => {
        cycleNextImage();
      }, 2000); // Changer une image toutes les 2 secondes
    }
    
    // Fonction pour démarrer le cycle automatique (ancienne version, gardée pour compatibilité)
    function startAutoCycle() {
      startProgressiveCycle();
    }
    
    // Attendre que le DOM soit chargé et que le script de configuration soit disponible
    document.addEventListener('DOMContentLoaded', function() {
      // Vérifier que le script de configuration est chargé
      if (typeof IMAGES_CONFIG === 'undefined') {
        console.error('IMAGES_CONFIG is not defined. Make sure dist/images-config.js is loaded.');
        // Essayer de charger le script de configuration dynamiquement
        const script = document.createElement('script');
        script.src = 'dist/images-config.js';
        script.onload = function() {
          console.log('Images config loaded');
          renderBackgroundCanvas().then(() => {
            // Démarrer le cycle automatique après le premier rendu
            startAutoCycle();
          });
        };
        script.onerror = function() {
          console.error('Failed to load images-config.js');
        };
        document.head.appendChild(script);
      } else {
        renderBackgroundCanvas().then(() => {
          // Démarrer le cycle automatique après le premier rendu
          startAutoCycle();
        });
      }
    });
  </script>
  <script src="dist/fade_in.js"></script>
</body>

</html>